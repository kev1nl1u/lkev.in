<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Shell</title>
	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=location_on,not_listed_location" />
	<link rel="stylesheet" href="css/style.css">
</head>
<body spellcheck="false">

	<div class="container">

	<div class="sh">
		<div class="head">
			<p>&copy;<span class="year"></span> lkev.in</p>
			<p>Welcome to <span class="url"></span></p>
			<br/>
			<p><span class="date"></span> @ <span class="user-agent"></span> <span class="ip"></span> <span class="location"></span></p>
			<p>* Last login <span class="last-date"></span> @ <span class="last-user-agent"></span> <span class="last-ip"></span> <span class="last-location"></span></p>
			<br/>
			<p class="MOTD"></p>
			<p>Type <code>help</code> to get started.</p>
		</div>
		<div class="commands">
			<div class="line">
				<span class="linestart"><span class="user">user</span>@<span class="url"></span>:<span class="path">~</span>$</span>
				<div class="command-input active" contenteditable="true" spellcheck="false" autofocus autocomplete='off' autocapitalize="off" autocorrect="off"></div>
			</div>
		</div>
	</div>

	</div>

	<script>
		var currentYear = new Date().getFullYear();
		var domain = window.location.hostname || window.location.host || window.location.href.split("/")[2] || 'localhost';
		var userAgent;

		document.addEventListener("DOMContentLoaded", async function() {

			// year
			document.querySelectorAll('.year').forEach(el => el.textContent = currentYear);

			// domain
			document.querySelectorAll('.url').forEach(el => el.textContent = domain);

			// date
			const now = new Date();
			const options = {
				day: '2-digit',
				month: 'short',
				year: 'numeric',
				hour: '2-digit',
				minute: '2-digit',
				second: '2-digit',
				hour12: false,
				timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
			};
			const formattedDate = new Intl.DateTimeFormat(navigator.language, options).format(now);
			const dateEl = document.querySelector('.date');
			if (dateEl) dateEl.textContent = formattedDate;

			const lastDateEl = document.querySelector('.last-date');
			let lastDate = '<%= lastLogin.request_date %>' || 'never';
			// Format last login date if available
			if (lastDate !== 'never') {
				const lastDateObj = new Date(lastDate); // JS converts ISO string to local time automatically
				const options = {
					day: '2-digit',
					month: 'short',
					year: 'numeric',
					hour: '2-digit',
					minute: '2-digit',
					second: '2-digit',
					hour12: false
				};
				lastDate = new Intl.DateTimeFormat(navigator.language, options).format(lastDateObj);
			}
			if (lastDateEl) lastDateEl.textContent = lastDate;

			// User agent
			const os = getOS();
			const browser = getBrowser();
			if (!os && !browser) {
				userAgent = 'unknown agent';
			} else if (os && !browser) {
				userAgent = os;
			} else if (!os && browser) {
				userAgent = browser;
			} else {
				userAgent = os + ' / ' + browser;
			}
			const userAgentEl = document.querySelector('.user-agent');
			if (userAgentEl) userAgentEl.textContent = userAgent;

			const lastUserAgentEl = document.querySelector('.last-user-agent');
			if (lastUserAgentEl) lastUserAgentEl.textContent = '<%= lastLogin.user_agent %>' || 'unknown agent';

			// IP
			const ipEl = document.querySelector('.ip');
			const ipValue = await getIP(ipEl);

			const lastIpEl = document.querySelector('.last-ip');
			if (lastIpEl) lastIpEl.textContent = '<%= lastLogin.ip %>' || '';

			// Location
			const locationEl = document.querySelector('.location');
			const locationValue = await getLocation(ipValue, locationEl);
			
			const lastLocationEl = document.querySelector('.last-location');
			const lastLocationValue = '<%= lastLogin.location %>' || '';
			if (lastLocationEl) {
				lastLocationEl.innerHTML = lastLocationValue
					? `<span class="material-symbols-outlined">location_on</span> ${lastLocationValue}`
					: `<span class="material-symbols-outlined">not_listed_location</span>`;
			}

			// MOTD
			try {
				const response = await fetch('/api/motd');
				if (!response.ok) throw new Error(response.statusText);
				const data = await response.json();
				if (data.success && data.motd && data.motd.length > 0) {
					const motdHtml = data.motd.map((line, index) => `* ${line}<br/>`).join('');
					const motdEl = document.querySelector('.MOTD');
					if (motdEl) motdEl.innerHTML = motdHtml + '<br/>';
				}
			} catch (err) {
				console.error('Error fetching MOTD:', err);
			}

			// Save login info to backend
			try {
				const response = await fetch('/api/save-login', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					login_date: now.toISOString(),
					user_agent: userAgent || 'unknown agent',
					ip_address: ipValue || null,
					location: locationValue || null
				})
				});

				if (!response.ok) throw new Error(response.statusText);
				const data = await response.json();
			} catch (err) {
				console.error('Error saving login info:', err);
			}
		});

		// =============================
		// Helper functions
		// =============================
		async function getIP(ipEl) {
			try {
				const response = await fetch('https://api.ipify.org?format=json');
				if (!response.ok) throw new Error(response.statusText);
				const data = await response.json();
				const ip = data.ip || null;
				if (ipEl) ipEl.textContent = ip || 'unknown';
				return ip;
			} catch (error) {
				console.error('Error fetching IP address:', error);
				if (ipEl) ipEl.textContent = 'unknown';
				return null;
			}
		}

		async function getLocation(ip, locationEl) {
			try {
				const response = await fetch(`https://ipapi.co/${ip}/json/`);
				if (!response.ok) throw new Error(response.statusText);
				const data = await response.json();
				if (data.error) throw new Error(data.reason || 'Unknown error');
				const location = [data.city, data.country_name]
					.filter(Boolean)
					.join(', ') || null;
				if (locationEl) {
					locationEl.innerHTML = location
						? `<span class="material-symbols-outlined">location_on</span> ${location}`
						: `<span class="material-symbols-outlined">not_listed_location</span>`;
				}
				return location;
			} catch (error) {
				console.error('Error fetching location:', error);
				return null;
			}
		}

		function getOS() {
			const platform = navigator.platform.toLowerCase();
			if (platform.includes('win')) return 'Windows';
			if (platform.includes('mac')) return 'MacOS';
			if (platform.includes('linux')) return 'Linux';
			if (/iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase())) return 'iOS';
			if (/android/.test(navigator.userAgent.toLowerCase())) return 'Android';
			return 'Unknown';
		}

		function getBrowser() {
			const ua = navigator.userAgent;
			if (ua.includes("Chrome") && !ua.includes("Edg") && !ua.includes("OPR")) return "Chrome";
			if (ua.includes("Firefox")) return "Firefox";
			if (ua.includes("Safari") && !ua.includes("Chrome")) return "Safari";
			if (ua.includes("Edg")) return "Edge";
			if (ua.includes("OPR") || ua.includes("Opera")) return "Opera";
			return "Unknown";
		}


		// click anywhere to focus input - unless highlighting text
		$(document).on('click', function(e) {
			const selection = window.getSelection();
			if (selection && selection.toString().length === 0) {
				$('.command-input').focus();
			}
		});

		// Global handler: allow Ctrl+C anywhere on the page to stop live server updates
		document.addEventListener('keydown', function(e) {
			if ((e.key === 'c' || e.key === 'C') && (e.ctrlKey || e.metaKey)) {
				e.preventDefault();
				if (window.__serverInfoInterval && window.__serverInfoInterval.id) {
					clearInterval(window.__serverInfoInterval.id);
					const cid = window.__serverInfoInterval.containerId;
					if (cid) {
						const el = document.getElementById(cid);
						if (el) {
							const note = document.createElement('div');
							note.innerHTML = `<p>Live updates stopped (Ctrl+C).</p>`;
							el.appendChild(note);
						}
					}
					window.__serverInfoInterval = null;
					printNewPrompt();
				}
			}
		});

		var commands = []; // TODO save in localStorage
		var commandIndex = 0; // points at the next position to insert (empty)

		$(document).on('keydown', '.command-input.active', async function(e) {
			// Allow Ctrl+C to stop live updates or cancel the current command
			if (e.key === 'c' && (e.ctrlKey || e.metaKey)) {
				e.preventDefault();
				// If live server updates are running, stop them
				if (window.__serverInfoInterval && window.__serverInfoInterval.id) {
					clearInterval(window.__serverInfoInterval.id);
					const cid = window.__serverInfoInterval.containerId;
					if (cid) {
						const el = document.getElementById(cid);
						if (el) {
							const note = document.createElement('div');
							note.innerHTML = `<p>Live updates stopped (Ctrl+C).</p>`;
							el.appendChild(note);
						}
					}
					window.__serverInfoInterval = null;
					printOutput('<p>Live server updates stopped (Ctrl+C).</p>');
					printNewPrompt();
					return;
				}
				// Otherwise, cancel current typed command (like terminal behavior)
				const el = this;
				$(el).removeAttr('contenteditable').removeClass('active');
				printError('', 'command canceled');
				printNewPrompt();
				return;
			}
			if (e.key === 'Enter') {
				e.preventDefault();
				$(this).removeAttr("contenteditable");
				const command = $(this).text().trim();
				if (command.length === 0) {
					printNewPrompt();
					return;
				}
				if(commands.length === 0 || commands[commands.length - 1] !== command) commands.push(command);
				commandIndex = commands.length;
				$(this).removeClass("active");
				await handleCommand(command);
				// If command is `info server` or `info ... live` we keep the live panel active and do not create a new prompt
				const cmdLower = command.toLowerCase();
				const isInfoServer = cmdLower === 'info server' || cmdLower.startsWith('info server ') ;
				const isInfoLive = cmdLower.startsWith('info') && cmdLower.includes('live');
				if (isInfoServer || isInfoLive) {
					// leave focus on the document so global Ctrl+C can be used to stop live
					document.activeElement && document.activeElement.blur && document.activeElement.blur();
				} else if (!command.startsWith("sudo") || command == "sudo") {
					printNewPrompt();
				} else {
					printOutput(`<div class="line">[sudo] password:
<div class="password-input active" contenteditable="true" spellcheck="false" autofocus autocomplete='off' autocapitalize="off" autocorrect="off"></div></div>`
					);
					$('.password-input.active').focus();
					// event listeners
					var psw = "";
					$('.password-input.active')
					.on('beforeinput', function(e) {
						e.preventDefault(); // stop text from appearing in the contenteditable

						const inputType = e.originalEvent.inputType;
						const data = e.originalEvent.data;

						if (inputType === "insertText") {
						psw += data; // add typed char
						} else if (inputType === "deleteContentBackward") {
						psw = psw.slice(0, -1); // handle backspace
						}
					})
					.on('keydown', function(e) {
						if (e.key === 'Enter') {
						e.preventDefault();
						$(this).removeAttr("contenteditable").removeClass("active");

						if (psw.length === 0) {
							printError(command, 'no password entered');
							printNewPrompt();
							return;
						}

						$.ajax({
							url: '/api/sudo',
							method: 'POST',
							contentType: 'application/json',
							data: JSON.stringify({ password: psw, arg: command.slice(5).trim() }),
							success: async (response) => {
							if (response.valid) {
								const argCommand = command.slice(5).trim().split(' ')[0].toLowerCase();
								if (['clear', 'about', 'echo', 'cfu', 'ig', 'gh', 'li', 'fn', 'ferminotify', 'uni'].includes(argCommand)) {
								await handleCommand(command.slice(5).trim());
								} else {
								if (response.output && response.output.length > 0) {
									printOutput(`<p>${response.output}</p>`);
									if (response.redirect) {
									if (response.target === '_blank') window.open(response.redirect, '_blank');
									else window.open(response.redirect, '_self');
									}
								}
								}
								// If the sudo command was a motd change, refresh header MOTD
								const sudoArg = command.slice(5).trim();
								if (sudoArg && sudoArg.toLowerCase().startsWith('motd')) {
									// refresh header MOTD by fetching /api/motd
									try {
										const hdrRes = await fetch('/api/motd');
										if (hdrRes.ok) {
											const hdrData = await hdrRes.json();
											if (hdrData.success && hdrData.motd && hdrData.motd.length > 0) {
												const motdEl = document.querySelector('.MOTD');
												if (motdEl) motdEl.innerHTML = hdrData.motd.map(line => `* ${line}<br/>`).join('') + '<br/>';
											} else {
												const motdEl = document.querySelector('.MOTD');
												if (motdEl) motdEl.innerHTML = '';
											}
										}
									} catch (e) {
										console.error('Error refreshing header MOTD:', e);
									}
								}
							} else {
								printError(command, 'authentication failure');
							}
							printNewPrompt();
							},
							error: () => {
							printError(command, 'generic error');
							printNewPrompt();
							}
						});
						} else if (e.key === 'c' && (e.ctrlKey || e.metaKey)) {
						e.preventDefault();
						$(this).removeAttr("contenteditable").removeClass("active");
						printError(command, 'command canceled');
						printNewPrompt();
						}
					});
				}
			}else if (e.key === 'ArrowUp') {
				e.preventDefault();
				if (commands.length === 0) return; // no history
				commandIndex--;
				if (commandIndex < 0) {
					commandIndex = 0;
					return;
				}
				$(this).text(commands[commandIndex]);
				// put cursor at end
				const el = this;
				const range = document.createRange();
				const sel = window.getSelection();
				range.selectNodeContents(el);
				range.collapse(false);
				sel.removeAllRanges();
				sel.addRange(range);
			} else if (e.key === 'ArrowDown') {
				e.preventDefault();
				if (commands.length === 0) return; // no history
				commandIndex++;
				if (commandIndex >= commands.length) {
					$(this).text('');
					return;
				}
				$(this).text(commands[commandIndex]);
				// put cursor at end
				const el = this;
				const range = document.createRange();
				const sel = window.getSelection();
				range.selectNodeContents(el);
				range.collapse(false);
				sel.removeAllRanges();
				sel.addRange(range);
			}
		});

		function getOS() {
			const platform = navigator.platform.toLowerCase();
			if (platform.includes('win')) return 'Windows';
			if (platform.includes('mac')) return 'MacOS';
			if (platform.includes('linux')) return 'Linux';
			if (/iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase())) return 'iOS';
			if (/android/.test(navigator.userAgent.toLowerCase())) return 'Android';
			return 'Unknown';
		}
		function getBrowser() {
			const ua = navigator.userAgent;
			if (ua.includes("Chrome") && !ua.includes("Edg") && !ua.includes("OPR")) return "Chrome";
			if (ua.includes("Firefox")) return "Firefox";
			if (ua.includes("Safari") && !ua.includes("Chrome")) return "Safari";
			if (ua.includes("Edg")) return "Edge";
			if (ua.includes("OPR") || ua.includes("Opera")) return "Opera";
			return "Unknown";
		}

		// =============================
		// Terminal Command System
		// =============================
		
		// Helper functions for terminal output
		function printOutput(content) {
			$('.commands').append(`<div class="output line">${content}</div>`);
		}

		function printError(command, message) {
			if (command && command.length > 0)
				printOutput(`<p>${command}: ${message}</p>`);
			else
				printOutput(`<p>${message}</p>`);
		}

		function validateNoArgs(command, args) {
			if (args.length > 0) {
				printError(command, `unrecognized argument: ${args.join(' ')}`);
				return false;
			}
			return true;
		}

		// Command configuration with args validation
		const commandConfig = {
			help: {
				acceptsArgs: false,
				description: 'display this help message',
				execute: (args) => {
					if (!validateNoArgs('help', args)) return;
					
					printOutput(`
						<p>${domain} ${userAgent} Bash, version 1.0-release<br/>These shell commands are defined internally. Type 'help' to see this list.</p>
						<p><strong>Core commands:</strong></p>
						<div class="command-help-list">
							<p><code>help</code> display this help message [command]</p>
							<p><code>about</code> information about me</p>
							<p><code>sudo</code> get superuser privileges [command [arg...]]</p>
							<p><code>motd</code> view the message of the day</p>
							<p><code>echo</code> display text [text]</p>
							<p><code>clear</code> clear the terminal</p>
							<p><code>exit</code> exit the terminal</p>
						</div>
						<p><strong>Link commands:</strong></p>
						<div class="command-help-list">
							<p><code>ls</code> list connections</p>
							<p><code>ferminotify</code> / <code>fn</code> connect to Fermi Notify [<code>-blank</code>, <code>-status</code>]</p>
							<p><code>uni</code> connect to my uni tools [<code>-blank</code>]</p>
							<p><code>ig</code> my Instagram [<code>-blank</code>]</p>
							<p><code>gh</code> my GitHub [<code>-blank</code>]</p>
							<p><code>li</code> my LinkedIn [<code>-blank</code>]</p>
						</div>
						<p><strong>Utility:</strong></p>
						<div class="command-help-list">
							<p><code>info</code> system information [<code>server</code>]</p>
							<p><code>weather</code> weather in your location [location]</p>
							<p><code>cfu</code> get my current cfu count</p>
							<p><code>env</code> display .env file</p>
						</div>
					`); // TODO fn status - format weather and add more days
				}
			},
			
			clear: {
				acceptsArgs: false,
				description: 'clear the terminal',
				execute: (args) => {
					if (!validateNoArgs('clear', args)) return;
					$('.sh').html('<div class="commands"></div>');
				}
			},
			
			about: {
				acceptsArgs: false,
				description: 'information about me',
				execute: (args) => {
					if (!validateNoArgs('about', args)) return;
					printOutput(`
						<p>I'm Kevin, a Computer Engineering student at the University of Padua (UniPD), and a graduate of I.S. E. Fermi Mantova.<br/>
						You can explore my open source projects on <a href="https://lkev.in/gh" target="_blank" rel="noopener">GitHub</a>.</p>
					`);
				}
			},
			
			ls: {
				acceptsArgs: false,
				description: 'list connections',
				execute: (args) => {
					if (!validateNoArgs('ls', args)) return;
					printOutput(`
						<p>Available connections:<br/>	
						<code>fn</code> / <code>ferminotify</code>: Fermi Notify<br/>
						<code>uni</code>: Uni tools<br/>
						<code>ig</code>: Instagram<br/>
						<code>gh</code>: GitHub<br/>
						<code>li</code>: LinkedIn<br/>
						Use [command] <code>-blank</code> to open in a new tab.</p>
					`);
				}
			},
			
			cfu: {
				acceptsArgs: false,
				description: 'get my current cfu count',
				execute: (args) => {
					if (!validateNoArgs('cfu', args)) return;
					printOutput('<p>WIP</p>');
				}
			},
			
			sudo: {
				acceptsArgs: true,
				description: 'get superuser privileges [command [arg...]]',
				execute: (args) => {
					if (args.length === 0) {
						printOutput('<p>usage: <code>sudo</code> [command [arg...]]</p>');
						return;
					}
					
				}
			},

			info: {
				acceptsArgs: true,
				description: 'your system information (use `info server` or `info live` to get server metrics)',
				execute: async (args) => {
					// Decide what the user requested:
					// - `info` => client-only
					// - `info server` => start server live updates (default live)
					// - `info live` => server live updates as well
					const argsLower = (args || []).map(a => a.toLowerCase());
					const wantsServer = argsLower.includes('server') || argsLower.includes('srv');
					const wantsLive = argsLower.includes('live') || wantsServer; // server implies live by default

					// Prepare client-side data (same as before)
					const screenRes = `${window.screen.width}x${window.screen.height}`;
					const colorDepth = `${window.screen.colorDepth}-bit`;
					const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
					const language = navigator.language || navigator.userLanguage;
					const cookiesEnabled = navigator.cookieEnabled ? 'Yes' : 'No';
					const jsEnabled = 'Yes';
					const platform = navigator.platform;
					const cpuCores = navigator.hardwareConcurrency || 'Unknown';
					const memory = navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Unknown';
					const dnt = navigator.doNotTrack == '1' ? 'Yes' : 'No';
					const online = navigator.onLine ? 'Online' : 'Offline';

					// If user didn't request server info, output basic client info
					if (!wantsServer) {
						printOutput(`
							<p><strong>Your System Information:</strong><br/>
							OS: ${getOS()}<br/>
							Browser: ${getBrowser()}<br/>
							User Agent: ${userAgent}<br/>
							Screen Resolution: ${screenRes}<br/>
							Color Depth: ${colorDepth}<br/>
							Platform: ${platform}<br/>
							CPU Cores: ${cpuCores}<br/>
							Device Memory: ${memory}<br/>
							Language: ${language}<br/>
							Timezone: ${timezone}<br/>
							Cookies Enabled: ${cookiesEnabled}<br/>
							JavaScript Enabled: ${jsEnabled}<br/>
							Do Not Track: ${dnt}<br/>
							Online Status: ${online}<br/>
							IP Address: <span class="ip">fetching...</span><br/>
							Location: <span class="location">fetching...</span></p>
						`);

						// Fetch IP and location for client info
						let ip = await getIP(document.querySelector('.commands .output .ip'));
						await getLocation(ip, document.querySelector('.commands .output .location'));
					}

					// If user asked for server info, fetch and display it
					if (wantsServer || wantsLive) {
						// create a container for server info and keep its id
						const containerId = `server-info-${Date.now()}`;
						printOutput(`<div id="${containerId}" class="server-info"></div>`);

						const el = document.createElement('div');
						el.innerHTML = '<p>Loading server info...</p>';
						el.classList.add('info-container');
						document.getElementById(containerId).appendChild(el);

						const renderServer = (data) => {
							if (!data) {
								el.innerHTML = '<p>Unable to fetch server info.</p>';
								return;
							}

							const cpu = data.cpu || {};
							const load = data.load || {};
							const mem = data.memory || {};
							const temp = data.temperature && data.temperature.main ? `${data.temperature.main} ¬∞C` : (data.temperature ? JSON.stringify(data.temperature) : 'N/A');

							const perCore = (load.cpus && load.cpus.length) ? load.cpus.map((c, i) => `Core ${i}: ${c.load.toFixed(1)}%`).join('<br/>') : '';

							el.innerHTML = `
								<p><strong>Server System Information (as of ${new Date(data.timestamp).toLocaleString()}):</strong><br/>
								CPU: ${cpu.manufacturer || ''} ${cpu.brand || ''} (${cpu.cores || cpu.physicalCores || 'N/A'} cores)<br/>
								Load: ${load.currentLoad ? load.currentLoad.toFixed(1) + '%' : (load.avgLoad || 'N/A')}<br/>
								Memory: ${mem.used ? Math.round((mem.used / mem.total) * 100) + '% used' : 'N/A'} (${mem.used || 'N/A'} / ${mem.total || 'N/A'})<br/>
								Uptime: ${Math.floor((data.uptime || 0) / 3600)}h ${Math.floor(((data.uptime || 0) % 3600) / 60)}m<br/>
								Temperature: ${temp}<br/>
								<div>${perCore}</div>
								</p>
							`;
						};

						// fetch once
						const fetchAndRender = async () => {
							try {
								const resp = await fetch('/api/sysinfo/cpu');
								if (!resp.ok) throw new Error(resp.statusText);
								const data = await resp.json();
								renderServer(data);
							} catch (e) {
								el.innerHTML = `<p>Error fetching server info: ${e.message}</p>`;
							}
						};

						await fetchAndRender();

						// If live requested, set an interval and store it globally so user can stop
						if (wantsLive) {
							// clear previous if exists
							if (window.__serverInfoInterval) clearInterval(window.__serverInfoInterval.id);
							const id = setInterval(fetchAndRender, 2000);
							window.__serverInfoInterval = { id, containerId };
							const infoNote = document.createElement('div');
							infoNote.innerHTML = `<p>Live updates every 2s. Use <code>CTRL+C</code> to stop.</p>`;
							document.getElementById(containerId).appendChild(infoNote);
						}
					}
				}
			},

			weather: {
				acceptsArgs: true,
				description: 'weather in your location [location]',
				execute: async (args) => {
					let locationInput = args.join(' ');
					let lat, lon, displayLocation;

					// Step 1: Get coordinates from location name OR use IP
					try {
						if (!locationInput) {
							const locRes = await fetch('https://ipapi.co/json/');
							const locData = await locRes.json();
							lat = locData.latitude;
							lon = locData.longitude;
							displayLocation = `${locData.city}, ${locData.country_name}`;
						} else {
							const geoRes = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(locationInput)}`);
							const geoData = await geoRes.json();
							if (!geoData.results || geoData.results.length === 0) throw new Error("Location not found.");
							const place = geoData.results[0];
							lat = place.latitude;
							lon = place.longitude;
							displayLocation = `${place.name}, ${place.country}`;
						}
					} catch (err) {
						printError('weather [location]', 'Could not resolve location.');
						return;
					}

					// Step 2: Get weather and timezone
					try {
						// Get weather data
						const weatherRes = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&timezone=auto`);
						const weatherData = await weatherRes.json();
						
						if (!weatherData.current_weather) {
							throw new Error('No weather data available');
						}
						
						const weather = weatherData.current_weather;
						const timezone = weatherData.timezone || 'UTC';

						// Map weather codes to descriptions with material icons // TODO
						const weatherCodes = {
							0: 'Clear ‚òÄÔ∏è',
							1: 'Mainly clear üå§Ô∏è',
							2: 'Partly cloudy ‚õÖ',
							3: 'Overcast ‚òÅÔ∏è',
							45: 'Fog üå´Ô∏è',
							48: 'Depositing rime fog ‚ùÑÔ∏èüå´Ô∏è',
							51: 'Light drizzle üå¶Ô∏è',
							53: 'Moderate drizzle üåßÔ∏è',
							55: 'Dense drizzle üåßÔ∏è',
							56: 'Freezing drizzle ‚ùÑÔ∏èüåßÔ∏è',
							57: 'Freezing dense drizzle ‚ùÑÔ∏èüåßÔ∏è',
							61: 'Slight rain üå¶Ô∏è',
							63: 'Moderate rain üåßÔ∏è',
							65: 'Heavy rain üåßÔ∏èüíß',
							66: 'Freezing rain ‚ùÑÔ∏èüåßÔ∏è',
							67: 'Heavy freezing rain ‚ùÑÔ∏èüåßÔ∏è',
							71: 'Slight snow üå®Ô∏è',
							73: 'Moderate snow üå®Ô∏è',
							75: 'Heavy snow üå®Ô∏è‚ùÑÔ∏è',
							77: 'Snow grains ‚ùÑÔ∏è',
							80: 'Slight rain showers üå¶Ô∏è',
							81: 'Moderate rain showers üå¶Ô∏è',
							82: 'Violent rain showers ‚õàÔ∏è',
							85: 'Slight snow showers üå®Ô∏è',
							86: 'Heavy snow showers üå®Ô∏è‚ùÑÔ∏è',
							95: 'Thunderstorm ‚õàÔ∏è',
							96: 'Thunderstorm with hail ‚õàÔ∏èüå®Ô∏è',
							99: 'Thunderstorm with heavy hail ‚õàÔ∏èüå®Ô∏è',
						};

						const condition = weatherCodes[weather.weathercode] || 'Unknown';

						// Get current local time in the location's timezone
						const now = new Date();
						const formattedTime = now.toLocaleString('en-US', {
							timeZone: timezone,
							day: '2-digit',
							month: 'short',
							year: 'numeric',
							hour: 'numeric',
							minute: '2-digit',
							hour12: false
						});

						printOutput(`
							<p><strong>Weather in ${displayLocation}:</strong><br/>
							Condition: ${condition}<br/>
							Temperature: ${weather.temperature}¬∞C<br/>
							Wind Speed: ${weather.windspeed} km/h<br/>
							Local Time: ${formattedTime} (${timezone})</p>
						`);
					} catch (err) {
						console.error('Weather fetch error:', err);
						printError('weather', 'could not fetch weather data');
					}

				}
			},

			motd: {
				acceptsArgs: false,
				description: 'display message of the day',
				execute: async (args) => {
					if (!validateNoArgs('motd', args)) return;
					try {
						const response = await fetch('/api/motd');
						if (!response.ok) throw new Error(response.statusText);
						const data = await response.json();
						if (data.success && data.motd && data.motd.length > 0) {
							let motdHtml = '<p>';
							motdHtml += data.motd.map((line, index) => `${index + 1}. ${line}<br/>`).join('');
							motdHtml += '</p>';
							printOutput(motdHtml);
						} else {
							printOutput('<p>No message of the day set.</p>');
						}
					} catch (err) {
						console.error('Error fetching MOTD:', err);
						printError('motd', 'could not fetch message of the day');
					}
				}
			},

			env: {
				acceptsArgs: false,
				description: 'display .env file',
				execute: (args) => {
					if (!validateNoArgs('env', args)) return;
					printOutput(`<p>USER="you"<br/>STUPID="true"<br/>ASTI="esplosa"<br/>SUDO="nano"</p>
					`);
				}
			},
			
			echo: {
				acceptsArgs: true,
				description: 'display text',
				execute: (args) => {
					const text = args.length > 0 ? args.join(' ') : '';
					printOutput(`<p>${text}</p>`);
				}
			},

			exit: {
				acceptsArgs: false,
				description: 'exit the terminal',
				execute: (args) => {
					if (!validateNoArgs('exit', args)) return;
					printOutput('<p>Exiting terminal...</p>');
					setTimeout(() => {
						window.close();
						printError('exit', 'Unable to close terminal.');
					}, 1000);
				}
			}
		};

		// Link configuration with supported options
		const linkConfig = {
			fn: { url: 'https://fn.lkev.in', name: 'Fermi Notify' },
			ferminotify: { url: 'https://fn.lkev.in', name: 'Fermi Notify' },
			uni: { url: 'https://unipv.lkev.in', name: 'Uni tools' },
			ig: { url: 'https://lkev.in/ig', name: 'Instagram' },
			gh: { url: 'https://lkev.in/gh', name: 'GitHub' },
			li: { url: 'https://lkev.in/li', name: 'LinkedIn' }
		};

		function handleLinkCommand(command, args, config) {
			if (args.length === 0) {
				window.open(config.url, '_self');
				printOutput(`<p>Connecting to ${config.name}...</p>`);
			} else if (args.length === 1 && args[0] === '-blank') {
				window.open(config.url, '_blank');
				printOutput(`<p>Connecting to ${config.name} in a new tab...</p>`);
			} else {
				printError(command, `unrecognized argument: ${args.join(' ')}`);
			}
		}

		async function handleCommand(input) {
			const commandParts = input.trim().split(' ');
			const command = commandParts[0].toLowerCase();
			const args = commandParts.slice(1);

			// Check built-in commands
			if (commandConfig[command]) {
				await commandConfig[command].execute(args);
			}
			// Check link commands
			else if (linkConfig[command]) {
				handleLinkCommand(command, args, linkConfig[command]);
			}
			// Unknown command
			else {
				printError('', `Unrecognized command: ${command}`);
			}

			window.scrollTo(0, document.body.scrollHeight);
		}

		function printNewPrompt(){
			$('.commands').append(`
<div class="line">
	<span class="linestart"><span class="user">user</span>@<span class="url">${domain}</span>:<span class="path">~</span>$</span>
	<div class="command-input active" contenteditable="true" autofocus autocomplete='off' autocapitalize="off" autocorrect="off"></div>
</div>
			`);
			$('.command-input.active').focus();
			window.scrollTo(0, document.body.scrollHeight);
		}
	</script>
</body>
</html>
		